\documentclass{beamer}
\mode<presentation>
 \usetheme{CambridgeUS}
%\usepackage{bussproofs}
%\usetheme{Singapore}
%\usecolortheme{lily}
  %%\usetheme{Logictheme} %nothing else
  %\setbeamertemplate{footline}[frame number]
  
%%\usepackage{bussproofs}
%%\usepackage[latin1]{inputenc} 
%%\newcommand{\mypause}{}
%%\newcommand{\mypause}{\pause}


%\institute[Madrid]{Swansea Railway Verification Group, Critical Software Technologies, Invensys Rail\\ \quad}
%\title[Logic in Railway Verification]{Application of Logic to the Verification\\ of Railway Control Systems}
%\title[Surrey Workshop]{Modelling and Analyzing the European Rail Traffic Management %System (ERTMS)}
\title[Pythonic Parsing with Pyparsing]{Pythonic Parsing with Pyparsing}

\author[Andrew Lawrence]{Andrew Lawrence}
\date[PyCon UK, 17 September 2018]{PyCon UK 2018\\[1em]  Cardiff, 17 September 2018}
%\institute[Swansea University]{Joint work with Andrew Lawrence, Ulrich Berger,  Phil James, Markus Roggenbach}

\usepackage{tikz}
\usepackage{graphicx}
\usetikzlibrary{shapes}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usepackage{tikz-uml}
\usepackage{verbatim}
\newcommand{\Red}{\mathbf{Red}}
\usepackage[nounderscore]{syntax}
\usepackage[linguistics]{forest}
%\usepackage{forest}

\newtheorem{mydef}{Definition}
\newtheorem{myremark}{Remark}
\newcommand{\ednote}[1]{{\bf #1}}
\newcommand{\fig}[1]{Fig.~\ref{fig:#1}}
\newcommand{\Val}{{\rm Val}}
\newcommand{\unprime}{{\rm unprime}}
\newcommand{\Vars}{{\rm Vars}}
\definecolor{bottomcol}{RGB}{222,222,222}


\begin{document}
\tikzstyle{class}=[
    rectangle,
    draw=black,
    text centered,
    anchor=north,
    text=black,
    text width=3cm,
    shading=axis,
    bottom color=bottomcol,top color=white,shading angle=45]


\begin{frame}
  \titlepage
\end{frame}



\begin{frame}

\frametitle{Workshop Overview}

\medskip
This workshop aims to give an introduction to parsing using the Pyparsing library
%\pause

\medskip

Overview:

\begin{itemize}
  \item \underline{Part I:} Parsing Introduction
  \item \underline{Part II:} Pyparsing Basics
  \item \underline{Part III:} Exercise 1: Dice Rolling
  \item \underline{Part IV:} Intermediate Pyparsing
  \item \underline{Part V:} Exercise 2: JSON Parser
  \item \underline{Part VI:} Advanced Pyparsing
\end{itemize}

\end{frame}

\begin{frame}

\frametitle{Prerequisites}
I am assuming that you have \textbf{Python 3} and \textbf{git} installed. You can get the workshop examples from Github:
\begin{center}
\textit{git clone https://github.com/andrewjlawrence/pyparsingworkshop.git}
\end{center}
\bigskip
You also need to install Pyparsing. 
\begin{center}
\textit{pip install pyparsing}
\end{center}
\end{frame}

\section{Parsing Introduction}

%\begin{frame}
%\begin{center}
%{\Large ERTMS -- what it is}
%\end{center}

%\end{frame}


\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20,
    minimum height=2em]


\begin{frame}
\frametitle{Why do we need parsers?}
The world is full of textual data in human readable formats. \\
\bigskip
The problem here is getting computers to understand this data.
\end{frame}

\begin{frame}
\frametitle{What is a parser?}
Typically parsing involves 3 stages:
\medskip
\begin{description}
\item[Lexical Analysis] Break the string down into \textbf{tokens}

\item[Syntactic Analysis] Construct a \textbf{syntax tree} based on some grammar

\item[Semantic Interpretation] Do something based on the syntax tree
\end{description}

\end{frame}
    

\begin{frame}
\frametitle{What is a parser?}
\begin{center}
\scalebox{0.8}
{
\begin{tikzpicture}[node distance = 2cm]
    % Place nodes
    \node [cloud] (init) {Source String};
    \node [block, below of=init] (lex) {Lexical Analysis};
    \node [cloud, below of=lex] (tokens) {Tokens};
    \node [block, below of=tokens] (syntax) {Syntactic Analysis};
    \node [cloud, below of=syntax] (parsetree) {Syntax Tree};
    % Draw edges
    \path [line] (init) -- (lex);
    \path [line] (lex) -- (tokens);
    \path [line] (tokens) -- (syntax);
    \path [line] (syntax) -- (parsetree);
\end{tikzpicture}
}
\end{center}
\end{frame}

\begin{frame}
\frametitle{What is a Grammar?}

A \textbf{grammar} is a set of rules that describes the structure of text.
\end{frame}


\begin{frame}[fragile]
\frametitle{Backus-Naur Form (BNF)}
A Backus-Naur form (BNF) is metasyntax notation for describing grammars.

\begin{center}
  \begin{tabular}{ | c | c | }
    \hline
    element type & description \\ \hline\hline
    $<\mathrm{non terminals}>$ & non terminal symbols  \\ \hline
    \textbf{terminals} & terminal symbols  \\ \hline
    $|$ & choice  \\ \hline
    ::= & replaced-by  \\ \hline
    * & repetition \\
    \hline
  \end{tabular}
\end{center}

\end{frame}

\begin{frame}[fragile]
\frametitle{Arithmetic Example Grammar}
\begin{grammar}
<sum> ::= <sum> $\mathbf{+}$ <product> | <product>

<product> ::= <product> $\mathbf{*}$ <value> | <value>

<value> ::= <int> | \textit{id}

<int> ::= <unsignedint> | $\mathbf{-}$<unsignedint>

<unsignedint> ::= <digit> | <unsignedint><digit>

<digit> ::= $\mathbf{0}$ | $\mathbf{1}$ | $\mathbf{2}$ | $\mathbf{3}$ | $\mathbf{4}$ | $\mathbf{5}$ | $\mathbf{6}$ | $\mathbf{7}$ | $\mathbf{8}$ | $\mathbf{9}$
 \end{grammar}
\end{frame}


\begin{frame}
\frametitle{Regular Expressions}
A \textit{regular expression} is a syntactic notation for defining textual patterns. \\
\bigskip
Example: \texttt{a|b*} denotes ${\{ \epsilon, "a", "b", "bb", "bbb", \ldots \}}$ \\
\bigskip
I won't go into further detail about how these work but beaware that they exist.
\end{frame}


\begin{frame}[fragile]
\frametitle{BNF Extensions}
There are a number of extensions to BNF. One common approach, as seen in extended Backus-Naur form is to use operations from regular expressions such as:

\begin{description}
\item[*]  - Match the preceeding element zero or more times. Often called the \underline{\textbf{Kleene Star}}.
\item[+]  - Match the preceeding element one or more times
\end{description}

\end{frame}



\begin{frame}
\frametitle{Types of Parsers}
\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass{Parser} 
\umlsimpleclass[x=-2, y=-3]{Top down} 
\umlsimpleclass[x=2, y=-3]{Bottom up}
\umlVHVinherit{Top down}{Parser} 
\umlVHVinherit{Bottom up}{Parser} 
\end{tikzpicture}
\end{center}
\end{frame}



\tikzset{
    invisible/.style={opacity=0,text opacity=0},
    visible on/.style={alt=#1{}{invisible}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
}
\forestset{
  visible on/.style={
    for current and ancestors={
      /tikz/visible on={#1},
      edge={/tikz/visible on={#1}}}}}

\begin{frame}
\frametitle{Example Parse Tree}
\begin{center}
\scalebox{0.8} {
\begin{forest}
  for tree={
    if n children=0{
      font=\itshape,
      tier=terminal,
      l sep=20pt,
      minimum width=1.8cm
    }{},
  }
[sum
  [sum
    [product
      [product
        [value
          [id
            [$x$]
          ]
        ]
      ]
      [$*$]
      [value
        [int 
          [$2$]
        ]
      ]
    ]
  ]
  [$+$]
  [product 
    [value
      [int
        [$1$]
      ]
    ]
  ]
]
\end{forest}
}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Bottom Up (LR) Parse}
\begin{center}
\scalebox{0.8} {
\begin{forest}
  for tree={
    if n children=0{
      font=\itshape,
      tier=terminal,
      l sep=20pt,
      minimum width=1.8cm
    }{},
  }
[sum (13), , visible on=<13->
  [sum (8), , visible on=<8->
    [product (7), visible on=<7->
      [product (3), visible on=<3->
        [value (2), visible on=<2->
          [id (1), visible on=<1->
            [$x$, visible on=<1->]
          ]
        ]
      ]
      [$\overset{(4)}{*}$, visible on=<4->]
      [value (6), visible on=<6->
        [int (5), visible on=<5->
          [$2$, visible on=<5->]
        ]
      ]
    ]
  ]
  [$\overset{(9)}{+}$, , visible on=<9->]
  [product (12) , visible on=<12->
    [value (11), visible on=<11->
      [int (10),  visible on=<10->
        [$1$,  visible on=<10->]
      ]
    ]
  ]
]
\end{forest}
}
\end{center}
\end{frame}
\tikzset{
    invisible/.style={opacity=0,text opacity=0},
    visible on/.style={alt=#1{}{invisible}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
}
\forestset{
  visible on/.style={
    for tree={
      /tikz/visible on={#1},
      edge+={/tikz/visible on={#1}}}}}


\begin{frame}
\frametitle{Top Down Parse}
\begin{center}
\scalebox{0.8} {
\begin{forest}
  for tree={
    if n children=0{
      font=\itshape,
      tier=terminal,
      l sep=20pt,
      minimum width=1.8cm
    }{},
  }
[sum (1), visible on=<1->
  [sum (2), visible on=<2->
    [product (3), visible on=<3->
      [product (4), visible on=<4->
        [value (5), visible on=<5->
          [id (6), visible on=<6->
            [$x$, visible on=<6->]
          ]
        ]
      ]
      [$\overset{(7)}{*}$, visible on=<7->]
      [value (8), visible on=<8->
        [int (9), visible on=<9->
          [$2$, visible on=<9->]
        ]
      ]
    ]
  ]
  [$\overset{(10)}{+}$, visible on=<10->]
  [product (11), visible on=<11->
    [value (12), visible on=<12->
      [int (13), visible on=<13->
        [$1$, visible on=<13->]
      ]
    ]
  ]
]
\end{forest}
}
\end{center}
\end{frame}


%\begin{frame}
%\frametitle{More detailed description of recursive decent parsing}
%\end{frame}

\begin{frame}[fragile]
\frametitle{Why Are Regular Expressions Bad You Ask?}
Below is part of a regex for validating RFC822 email addresses.
\begin{verbatim}
(?:(?:\\r\\n)?[ \\t])*(?:(?:(?:[^()<>@,;:\\\\".\\[\\]
 \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|
(?=[\\["()<>@,;:\\\\".\\[\\]]))|"(?:[^\\\\"\r\\\\]|\\\\.|
(?:(?:\\r\\n)?[ \\t]))*"(?:(?:\\r\\n)?[ \\t])*)
(?:\\.(?:(?:\\r\\n)?[ \\t])
*(?:[^()<>@,;:\\\\".\\[\\] \\000-\\031]+
(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|
(?=[\\["()<>@,;:\\\\".\\[\\]]))|"
(?:[^\\"\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \t]))
*"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t])*
\end{verbatim}
The full regex is 6.2KB in size.

\end{frame}


\begin{frame}[fragile]
\frametitle{Why Are Regular Expressions Bad You Ask?}
Why are regular expressions bad?

\begin{enumerate}
\pause
\item Difficult to read
\pause
\item Hard to maintain - Write only
\pause
\item Different standards exist
\end{enumerate}

\end{frame}

\section{Pyparsing Basics}

\begin{frame}
\frametitle{Pyparsing Overview}
Pyparsing is a recursive decent parser framework for the Python programming language. \\
\medskip
Created by Paul McGuire in 2003.
\medskip
Follows the parser combinator approach to parsing. You build your parser by combining other parsers.
\end{frame}


\begin{frame}
\frametitle{Pyparsing Advantages}
Pyparsing is a recursive decent parser framework for the Python programming language. \\
\bigskip
More powerful than regular expressions.\\
\bigskip
Lets us define parsers using a BNF style notation
\end{frame}


\begin{frame}
\frametitle{Pyparsing is Pythonic}
Pyparsing is pythonic. Consider the below points from "The Zen of Python": \\
\bigskip
\begin{itemize}
\item Beautiful is better than ugly.
\item Explicit is better than implicit.
\item Simple is better than complex.
\item Readability counts.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Arthmetic Example in Pyparsing}
Show arthmetic example
\end{frame}


\begin{frame}[fragile]
\frametitle{Getting Started}
Loading the module inside a Python script can be done like so
\begin{verbatim}
import pyparsing as pp
\end{verbatim}
\end{frame}


\begin{frame}
\frametitle{Parser Element}
The basic building block from which all other parsers are built
\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass{object} 
\umlclass[y=-3]{ParserElement}{}{parseString(self, instring) : ParseResults \\
	runTests(self, tests)
}
\umlVHVinherit{ParserElement}{object} 
\end{tikzpicture}
%     	parseString(self, instring) : ParseResults
%}
%        setParseAction(self, *fns, **kwargs)  \\
 %       runTests(self, tests, ...) }
\end{center}
\end{frame}



\begin{frame}[fragile]
\frametitle{parseString}
Applying the parser to a string is done using the \texttt{parseString} method.

\begin{verbatim}
sum.parseString("4 + 2 * 4")

=>

['4', '+', '2', '*', '4']
\end{verbatim}
It should be noted that whitespace is skipped by default.
\end{frame}


\begin{frame}[fragile]
\frametitle{runTests}
It is possible to run some simple tests using the \texttt{runTests} method.

\begin{verbatim}
tests = """
    1+2
    1+3+7
    -1*43
    -1+16*4
    """
sum.runTests(tests)
\end{verbatim}
The results will either show that the parse succeeded or where it failed. \\
\medskip
It is always advisable to write unit tests for real application development.
\end{frame}


\begin{frame}
\frametitle{Pyparsing Basics: Defining Tokens}
\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass{object} 
\umlsimpleclass[y=-2]{ParserElement}
\umlsimpleclass[y=-4]{Token}
\umlsimpleclass[x=-2, y=-6 ]{Literal}
\umlsimpleclass[x=2, y=-6 ]{Word}
\umlVHVinherit{ParserElement}{object} 
\umlVHVinherit{Token}{ParserElement} 
\umlVHVinherit{Literal}{Token} 
\umlVHVinherit{Word}{Token} 

\end{tikzpicture}
\end{center}
\end{frame}



\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Literal}
\texttt{Literal} can be used to exactly match a specified string
\begin{verbatim}
   Literal('blah').parseString('blah')  
        # -> ['blah']
   Literal('blah').parseString('blahfooblah')  
        # -> ['blah']
   Literal('blah').parseString('bla')  
        # -> Exception: Expected "blah"
\end{verbatim}
There is also a \texttt{CaselessLiteral} token class for case-insensitive matching.
\end{frame}

\begin{frame}[fragile]
 \frametitle{Pyparsing Basics: Word}
Token to match a word based on a provided character set. \\ 
\bigskip
The following grammar 
\begin{grammar}
<abstring> ::= ($\mathbf{a}$ | $\mathbf{b}$ | $\mathbf{A}$ | $\mathbf{B}$)*
 \end{grammar} 
\bigskip
is equivalent to this Python code
\begin{verbatim}
abstring = pp.Word("abAB")
 \end{verbatim}

\end{frame}


\begin{frame}[fragile]
 \frametitle{Pyparsing Basics: Word}
There are several helper strings for defining words \\ 
\begin{center}
  \begin{tabular}{ | c | c | }
    \hline
    helper string & description \\ \hline\hline
    alphas & alphabetic characters  \\ \hline
    nums & numbers \\ \hline
    alphanums & alphabetic characters + numbers  \\ \hline
    hexnums & hexidecimal numbers  \\ \hline
    alphas8bit & alphabetic characters in ASCII range 128-255 \\ \hline
    punc8bit & non-alphabetic characters in ASCII range 128-255 \\ \hline
    printables & any non-whitespace character \\
  \hline
  \end{tabular}
\end{center}

\end{frame}

\begin{frame}[fragile]
 \frametitle{Pyparsing Basics: Word}
In our arthmetic example we define \texttt{unsignedint} using the \texttt{Word} Token.
\begin{verbatim}
unsignedint = pp.Word(pp.nums)

unsignedint.parseString("123")
        # => ['123']	

unsignedint.parseString("abc")
# => pyparsing.ParseException: Expected W:(0123...)	
\end{verbatim}
\end{frame}

\begin{frame}
\frametitle{Pyparsing Basics: Word Length}
Word has some helpful parameters for lengths.



\end{frame}


\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Result Names}
It is possible to label results using a name
\begin{verbatim}
unsignedint = \
 pp.Word(pp.nums).setResultsName('Unsigned Integer')

unsignedint.runTests("""
        1
""") 
  =>
1
['1']
- Unsigned Integer: '1'
\end{verbatim}
\end{frame}


\begin{frame}
\frametitle{Pyparsing Basics: Keyword}
Todo describe keyword
\end{frame}



\begin{frame}
\frametitle{Pyparsing Basics: ParseExpressions}

\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass{object} 
\umlsimpleclass[y=-2]{ParserElement}
\umlsimpleclass[y=-4]{ParseExpression}
\umlsimpleclass[x=-4, y=-6 ]{And}
\umlsimpleclass[x=-1.5, y=-6 ]{Each}
\umlsimpleclass[x=1.5, y=-6 ]{MatchFirst}
\umlsimpleclass[x=4, y=-6 ]{Or}
\umlVHVinherit{ParserElement}{object} 
\umlVHVinherit{ParseExpression}{ParserElement} 
\umlVHVinherit{And}{ParseExpression} 
\umlVHVinherit{Each}{ParseExpression} 
\umlVHVinherit{MatchFirst}{ParseExpression} 
\umlVHVinherit{Or}{ParseExpression} 

\end{tikzpicture}
\end{center}

\end{frame}


\begin{frame}[fragile]
\frametitle{Pyparsing Basics: And}
The \texttt{And} parse expression, written infix as \texttt{+}, requires that the given ParseExpressions are found in order.

\begin{verbatim} 
pp.Literal("-") + unsignedint
\end{verbatim}

or as prefix notation
\begin{verbatim} 
pp.And([pp.Literal("-"), unsignedint])
\end{verbatim}

\end{frame}



\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Each}
The \texttt{Each} parse expression, written infix as \texttt{\&}, requires that the given ParseExpressions are matched, but in \textbf{any} order.
\begin{verbatim}
animal_type = pp.oneOf("CAT DOG HORSE FISH RAT")
type_attr = "type:" + animal_type("type")

name = pp.Word(pp.alphas)
name_attr = "name:" + name("pet name")

pet_spec = name_attr & type_attr
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Each}
\begin{verbatim}
pet_spec.runTests('''
    name: Brian type: DOG
    type: CAT name: Tom
    '''
        =>	
name: Brian type: DOG
['name:', 'Brian', 'type:', 'DOG']
- pet name: 'Brian'
- type: 'DOG'

type: CAT name: Tom
['type:', 'CAT', 'name:', 'Tom']
- pet name: 'Tom'
- type: 'CAT'
\end{verbatim}
\end{frame}


\begin{frame}[fragile]
\frametitle{Pyparsing Basics: MatchFirst}
The \texttt{MatchFirst} parse expression, written infix as \texttt{|}, requires that one of the ParseExpressions are matched with priority given from left to right.
\begin{verbatim}
unsignedint = pp.Word(pp.nums)
integer = 
    pp.Combine(
      pp.Literal("-") + unsignedint
    ).setResultsName("integer") | 
        unsignedint("unsigned integer")
\end{verbatim} 
\end{frame}




\begin{frame}[fragile]
\frametitle{Pyparsing Basics: MatchFirst}
\begin{verbatim}
integer.runTests("""
        1
        -1
""")

1
['1']
- unsigned integer: '1'

-1
['-1']
- integer: '-1'
\end{verbatim} 
\end{frame}

\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Or}
The \texttt{Or} parse expression, written infix as \texttt{\^}, requires that at least one of the ParseExpressions are matched with priority given to the longest.

\begin{verbatim}
number = Word(nums) ^ Combine(Word(nums) \
         + '.' + Word(nums))
number.searchString("123 3.1416 789"))
         =>
    [['123'], ['3.1416'], ['789']]
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Combine}
The \texttt{Combine} parse expression combines parsed tokens into a single string.

\begin{verbatim}
number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))
number.searchString("123 3.1416 789"))
    =>
[['123'], ['3.1416'], ['789']]
\end{verbatim}
Combine is actually enhancing the parser rather than chaning the grammar to be parsed.
\end{frame}


\begin{frame}
\frametitle{Pyparsing Basics: Parser Element Enhancements}
ParseElementEnhance provides an interface for parser enhancements which combine or post process tokens.
\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass[]{ParserElement}
\umlsimpleclass[y=-2]{ParseElementEnhance}
%\umlVHVinherit{ParserElement}{object} 
\umlVHVinherit{ParseElementEnhance}{ParserElement} 
\end{tikzpicture}
\end{center}

\end{frame}


\begin{frame}
\frametitle{Pyparsing Basics: Forward}
The first parser enhancement we will look at is \texttt{Forward}
\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass[]{ParseElementEnhance}
\umlsimpleclass[y=-2]{Forward}
%\umlVHVinherit{ParserElement}{object} 
\umlVHVinherit{Forward}{ParseElementEnhance} 
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Forward}
How do we handle recursion in Pyparsing? We cannot directly define \texttt{sum} like this:
\medskip
\begin{grammar}
<sum> ::= <sum> $\mathbf{+}$ <product> | <product>
\end{grammar}
\medskip
Instead we must forward declare sum and use an auxilary parser:
\begin{verbatim}
sum = pp.Forward()
sum_list = product + pp.Literal("+") + sum
sum << (sum_list | product)
\end{verbatim}
\end{frame}


\begin{frame}
\frametitle{Pyparsing Basics: Token Converters}
Token converters are used to convert parsed results
\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass{ParseElementEnhance} 
\umlsimpleclass[y=-2]{TokenConverter}
\umlsimpleclass[x=-4,y=-4]{Combine}
\umlsimpleclass[x=-1.5, y=-4]{Dict}
\umlsimpleclass[x=1.5,y=-4]{Group}
\umlsimpleclass[x=4, y=-4]{Suppress}

%\umlVHVinherit{ParserElement}{object} 
\umlVHVinherit{TokenConverter}{ParseElementEnhance} 
\umlVHVinherit{Combine}{TokenConverter} 
\umlVHVinherit{Dict}{TokenConverter} 
\umlVHVinherit{Group}{TokenConverter} 
\umlVHVinherit{Suppress}{TokenConverter} 

\end{tikzpicture}
\end{center}

\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise 1: Dice Rolling}
For our first exercise we will implement a dice roll parser. \\
\medskip
For example, the roll \textbf{2d6} can be interpretted as rolling two six sided dice. \\
\bigskip
Task 1) Complete the grammar 
\begin{grammar}
<diceroll> ::= ...
\end{grammar}
\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise 1: Dice Rolling}
For our first exercise we will implement a dice roll parser. \\
\medskip
For example, the roll \textbf{2d6} can be interpretted as rolling two six sided dice. \\
\bigskip
\textbf{\underline{Task 1)}} Complete the grammar 
\medskip
\begin{grammar}
<diceroll> ::= ...
\end{grammar}
\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise 1: Dice Rolling}
\begin{center}
Discussion...
\end{center}

\end{frame}

\begin{frame}[fragile]
\frametitle{Exercise 1: Dice Rolling}
One possible answer
\bigskip
\begin{grammar}
<digit> ::= $\mathbf{0}$ | $\mathbf{1}$ | $\mathbf{2}$ | $\mathbf{3}$ | $\mathbf{4}$ | $\mathbf{5}$ | $\mathbf{6}$ | $\mathbf{7}$ | $\mathbf{8}$ | $\mathbf{9}$

<numsides> ::= <digit>

<numdice> ::= <digit>

<diceroll> ::= <numdice>d<numsides>
\end{grammar}

\end{frame}

\begin{frame}
\frametitle{Exercise 1: Dice Rolling}
\textbf{\underline{Task 2)}} Now implement the parser in Python. You can find a template file with some tests in the exercises folder
\end{frame}


\begin{frame}
\frametitle{Pyparsing Basics: Suppress}
Suppress is a TokenConverter that throws away the parsed results
\begin{center}
\begin{tikzpicture}[post/.style={->,shorten >=1pt,>=stealth',semithick}] 
\umlsimpleclass{ParseElementEnhance} 
\umlsimpleclass[y=-2]{TokenConverter}
\umlsimpleclass[y=-4]{Suppress}

\umlVHVinherit{TokenConverter}{ParseElementEnhance} 
\umlVHVinherit{Suppress}{TokenConverter} 
\end{tikzpicture}
\end{center}

\end{frame}

\section{Pyparsing Intermediate}

\begin{frame}[fragile]
\frametitle{Pyparsing Basics: Suppress}
There are two ways to apply Suppress:
\begin{verbatim}
animal_type = pp.oneOf("CAT DOG HORSE FISH RAT")
type_attr = pp.Suppress("type:") + animal_type("type")

name = pp.Word(pp.alphas)
name_attr = pp.Literal("name:").suppress() + name("pet name")

pet_spec = name_attr & type_attr
\end{verbatim}
\end{frame}

\begin{frame}
TODO add more about token converters.
\end{frame}


\begin{frame}
\frametitle{Exercise 1: Dice Rolling}
\textbf{\underline{Task 3)}} Work out which tokens in your Dice Rolling Parser should be suppressed and remove them from the results. \\
\end{frame}





\begin{frame}
\frametitle{Adding Behavior to Parsers}
Parser Element lets us add additional parsing behavior with the \texttt{setParseAction} method.
\medskip

See example \textbf{sum-version2.py}.

\end{frame}

\begin{frame}
\frametitle{Exercise 1: Dice Rolling Task 4}
\textbf{\underline{Task 4}} Add a parse action to your dice roll parser that does a dice roll. 
\medskip
You may need to import the \texttt{random} module to do this.
\end{frame}

\begin{frame}
\frametitle{Exercise 2: JSON Parser}
For our second exercise we will write a parser for a simplified JSON (JavaScript Object Notation). \\
\medskip
This is a commonly used format for exchanging data.
\end{frame}


\begin{frame}
\frametitle{What is JSON?}
JSON is recursively from two types of datastructure can be interleaved:

\begin{itemize}
\item a collection of name value pairs (similar to a Python dictionary), called an \textbf{object}.
\item a list of values, called an \textbf{array}
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{JSON Object}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm,>=stealth',bend angle=45,auto]
  \tikzset{initial text=$ $,
              ->}
  \tikzstyle{literal}=[state,thick,draw=blue!75,fill=blue!20,minimum size=6mm]
  \tikzstyle{rule}=[rectangle,thick,draw=blue!75,fill=blue!20,minimum size=6mm]

  \tikzstyle{every label}=[red]
    \node [literal] (lbrack)                                    {\{};
    \node [state, draw=black, fill=black, minimum size=3mm] (initial) [left of=lbrack] {};
    \node [rule] (string)  [right of=lbrack]                               {string};
    \node [literal] (colon) [right of=string] {:};
    \node [rule] (value) [right of=colon] {value};
    \node [literal] (rbrack) [right of=value] {\}};
    \node [literal] (comma) [below of=colon] {,};
    \node [state, accepting, draw=black, fill=black, minimum size=3mm] (final) [right of=rbrack] {};

   \draw (initial) edge (lbrack)
            (lbrack) edge (string)
            (lbrack) edge[bend left, above] (rbrack)
            (string) edge (colon)
            (colon) edge (value)
            (value) edge (rbrack)
            (rbrack) edge (final)
            (value) edge[bend left, below] (comma)
            (comma) edge[bend left, below] (string) ;

\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{JSON Array}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm,>=stealth',bend angle=45,auto]
  \tikzset{initial text=$ $,
              ->}
  \tikzstyle{literal}=[state,thick,draw=blue!75,fill=blue!20,minimum size=6mm]
  \tikzstyle{rule}=[rectangle,thick,draw=blue!75,fill=blue!20,minimum size=6mm]

  \tikzstyle{every label}=[red]
    \node [literal] (lbrack)                                    {[};
    \node [state, draw=black, fill=black, minimum size=3mm] (initial) [left of=lbrack] {};
    \node [rule] (value) [right of=lbrack] {value};
    \node [literal] (rbrack) [right of=value] {]};
    \node [literal] (comma) [below of=value] {,};
    \node [state, accepting, draw=black, fill=black, minimum size=3mm] (final) [right of=rbrack] {};

   \draw (initial) edge (lbrack) 
            (lbrack) edge (value)
            (lbrack) edge[bend left, above] (rbrack)
            (value) edge (rbrack)
            (rbrack) edge (final)
            (value) edge[bend left, below] (comma)
            (comma) edge[bend left, below] (value) ;

\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{JSON Value}
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}[node distance=1.3cm,>=stealth',bend angle=45,auto]
  \tikzset{initial text=$ $,
              ->}
  \tikzstyle{literal}=[state,thick,draw=blue!75,fill=blue!20,minimum size=6mm]
  \tikzstyle{rule}=[rectangle,thick,draw=blue!75,fill=blue!20,minimum size=6mm]

  \tikzstyle{every label}=[red]

    \node [state, draw=black, fill=black, minimum size=3mm] (initial)  {};

    \node [rule] (array) [right of=initial] {array};
    \node [rule] (object) [above of=array] {object};
    \node [rule] (number) [above of=object] {number};
    \node [rule] (string) [above of=number] {string};
    \node [literal] (true) [below of=array] {true};
    \node [literal] (false) [below of=true] {false};
    \node [literal] (null) [below of=false] {null};
    \node [state, accepting, draw=black, fill=black, minimum size=3mm] (final) [right of=rbrack] {};

   \draw (initial) edge  [bend left, above]  (string)
            (initial) edge   [bend left, above]  (number)
            (initial) edge [bend left, above] (object)
            (initial) edge (array)
            (initial) edge [bend right] (true)
            (initial) edge [bend right] (false)
            (initial) edge [bend right] (null)
            (string) edge [bend left] (final)
            (number) edge [bend left] (final)
            (object) edge [bend left] (final)
            (array) edge  (final)
            (true) edge [bend right] (final)
            (false) edge [bend right] (final)
             (null) edge [bend right] (final);

\end{tikzpicture}
}
\end{center}
\end{frame}

\begin{frame}
\frametitle{JSON String}
We will use a heavily simplified version of the string for now.
\begin{center}
\begin{tikzpicture}[node distance=2cm,>=stealth',bend angle=45,auto]
  \tikzset{initial text=$ $,
              ->}
  \tikzstyle{literal}=[state,thick,draw=blue!75,fill=blue!20,minimum size=6mm]
  \tikzstyle{rule}=[rectangle,thick,draw=blue!75,fill=blue!20,minimum size=6mm]

  \tikzstyle{every label}=[red]

    \node [state, draw=black, fill=black, minimum size=3mm] (initial)  {};

    \node [literal] (leftquote) [right of=initial] {"};
    \node [rule] (alphanum) [right of=leftquote] {alphanum};
    \node [literal] (rightquote) [right of=alphanum] {"};
   \node [state, accepting, draw=black, fill=black, minimum size=3mm] (final) [right of=rightquote] {};

   \draw (initial) edge  (leftquote)
            (leftquote) edge (alphanum)
            (alphanum) edge (rightquote)
            (rightquote) edge (final)
            (alphanum) edge [loop above] (alphanum);

\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}
\frametitle{JSON Number}
We also use a heavily simplified version of the number.
\begin{center}
\begin{tikzpicture}[node distance=1.4cm,>=stealth',bend angle=45,auto]
  \tikzset{initial text=$ $,
              ->}
  \tikzstyle{literal}=[state,thick,draw=blue!75,fill=blue!20,minimum size=6mm]
  \tikzstyle{rule}=[rectangle,thick,draw=blue!75,fill=blue!20,minimum size=6mm]

  \tikzstyle{every label}=[red]

    \node [state, draw=black, fill=black, minimum size=3mm] (initial)  {};

    \node [literal] (minus) [below of=initial] {-};
    \node [rule] (onetonine) [right of=initial] {digit 1-9};
    \node [literal] (zero) [above of=initial] {0};
    \node [literal] (dot) [right of=onetonine] {.};
    \node [rule] (digit1) [below of=onetonine] {digit};
    \node [rule] (digit2) [right of=dot] {digit};
    \node [state, accepting, draw=black, fill=black, minimum size=3mm] (final) [right of=digit2] {};

   \draw (initial) edge (zero)
            (initial) edge (onetonine)
            (initial) edge (minus)
            (minus) edge (onetonine)
            (onetonine) edge (digit1)
            (digit1) edge [loop below] (digitone)
            (zero) edge [bend left] (final)
            (zero) edge [bend left] (dot)
            (onetonine) edge (dot)
            (dot) edge (digit2)
            (digit2) edge (final)
            (digit1) edge [bend right] (dot)
            (digit1) edge [bend right] (final)
            (digit2) edge [loop above] (digit2);

\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise 2 Create a JSON Parser: Task 1}
Create a parser for JSON \textbf{strings} using the following grammar:
\medskip
\begin{grammar}
<string> ::= "<alphanum>"
\end{grammar}

\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise 2 Create a JSON Parser: Task 2}
Create a parser for JSON \textbf{numbers} using the following grammar:
\medskip
\begin{grammar}
<number> ::= <int> <frac>

<int> ::=  <digit> | <onenine> <digits> | - <digit> | - <onenine><digits>

<frac> ::= "" | . <digits>

<digits> ::= <digit> | <digit> <digits>

<digit> ::= 0 | <onenine>

<onenine> ::= 1-9
\end{grammar}

\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise 2 Create a JSON Parser: Task 3}
Create a parser for JSON \textbf{values} using the following grammar:
\medskip
\begin{grammar}
<value> ::= <object> | <array> | <string> | <number> | true | false | null
\end{grammar}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exercise 2 Create a JSON Parser: Task 4}
Create a parser for JSON \textbf{arrays} using the following grammar:
\medskip
\begin{grammar}
<array> ::= [] | [ <values> ]

<values> ::= <value> | <value> , <values>
\end{grammar}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exercise 2 Create a JSON Parser: Task 5}
Create a parser for JSON \textbf{objects} using the following grammar:
\medskip
\begin{grammar}
<object> ::= \{ \} | \{ <members> \}

<members> ::= <member> | <member> , <members>

<member> ::= <string> : <value>
\end{grammar}
\end{frame}


\begin{frame}[fragile]
\frametitle{Dealing with Whitespace}
By default Pyparsing parsers automatically consume whitespace. \\
\medskip
It is possible to change this by using the \texttt{setDefaultWhitespaceChars} method e.g. \\
\medskip
\begin{verbatim}
ParserElement.setDefaultWhitespaceChars("\t")
\end{verbatim}
\bigskip
See example \textbf{whitespace.py}.

\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise 2 Create a JSON Parser: Task 6}
Extend the
\end{frame}





\end{document}



\begin{frame}
\frametitle{Intermediate Pyparsing}

\end{frame}



\begin{frame}
\frametitle{Lookahead with NotAny and FollowedBy}
\end{frame}

\begin{frame}
\frametitle{Parsing dictionaries with Dict}
\end{frame}


\begin{frame}
\frametitle{Forward declaring parsers with Forward}
\end{frame}


\begin{frame}
\frametitle{Exercise 2: JSON Parser}
\end{frame}

\begin{frame}
\frametitle{Advanced Pyparsing}
\end{frame}


\begin{frame}
\frametitle{Debugging parsers}
\end{frame}

\begin{frame}
\frametitle{Whitespace Management}
\end{frame}


\begin{frame}
\frametitle{Packrat Parsing}
\end{frame}



\begin{frame}
\frametitle{Summary}
\end{frame}


\end{document}
